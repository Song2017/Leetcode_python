
# 堆 
堆是一种特殊的树. 有意义的是堆顶元素
## 应用
堆排序, 堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法
? 堆排序比快速排序的时间复杂度稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好
## 概念
1. 堆是一个完全二叉树
    这使得堆可以用数组来存储
    除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列
2. 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值
    去掉了子节点之间的关系限制后, 降低了实现复杂度, 提高了排序性能
    大于: 大顶堆, 小于: 小顶堆
## 实现一个堆
1. 堆的存储
    存储堆的数组, 重点区分元素的值和元素的索引, 我们计算的是元素的索引, 数组索引有下面的规律:
    根节点从第1个位置开始时, 元素的索引值是一致的:
        节点索引为i时, 左子节点:i∗2，右子节点: i∗2+1，父节点: i/2
        例: 值/索引 0 1 2 3 4 5 6 7 8, 此时1所在的索引值为1
        节点: 左子节点, 右子节点 
            1: 2, 3
            2: 4, 5
            3: 6, 7 ...
    根节点从0开始时:
        节点索引为i时, 左子节点索引:i∗2 + 1，右子节点索引: i∗2+2，父节点索引: i-1/2
        例:值: 1 2 3 4 5 6 7 8 _, 此时1所在的元素索引为0
         索引: 0 1 2 3 4 5 6 7 9, 
        节点: 左子节点, 右子节点 
            0(1): 1(2), 2(3)
            1(2): 3(4), 4(5)
            ...
    两种保存方式都是可以的, 但是值和索引保持一致时, 计算和理解都容易很多, 这里采用第一种
2. 堆的操作
    1. 往堆中插入一个元素
        1. 堆化: 堆中插入新的元素后，进行调整，让其重新满足堆的特性的过程
            分类, 从下向上, 从上向下
        2. 插入元素不会出现破坏完全二叉树要求的情况, 一般采用从下向上堆化
            堆限制了父子节点之间的关系, 堆化过程中只要按层比对就可以了
        Code
        ```
        ```
    2. 删除堆顶元素
        1. 根据第二条概念可以知道堆顶元素存储的就是堆中数据的最大值或者最小值
        2. 删除堆顶元素后, 需要子节点进行补足, 迭代到子节点后, 容易出现空洞, 即不满足完全二叉树的情况:
            解决, 直接取最后的叶节点替换到堆顶, 然后从上向下堆化
        3. Code
        ```
        ```
## 实现堆排序
1. 建堆
    1. 从前向后: 假设堆中只有一个数据, 然后将下标从 2 到 n 的数据依次插入到堆中
    2. 从后向前: 
        大顶堆的存储数组顺序是按层排序,也就是说已完成排序堆的数组后面的数据是叶子节点, 
        再按照完全二叉树的定义, 叶子节点的下标是从n/2+1开始的, 
        我们只需要从n/2开始, 堆化到下标为1的数据就可以了
    3. 建堆的时间复杂度:  
        因为堆树每层内部的节点之间没有顺序关系, 高层的节点排序要经过低层节点, 
        所以时间复杂可以简单的记做:每层的节点数*层的高度之和
        设: 树的高度为h, 节点数为n. 已知: h = log2n
            因为叶子节点不需要进行比较, 所以不需要计算 h=0
            A: S = 2^0 * h + 2^1 * (h-1) + 2^2 * (h-2) + ... 2^(h-1) * 1
            B: 2*S =         2^1 * (h) + 2^2 * (h-1) + ...   2^(h-1) * 2  + 2^(h)
            B - A = S = -h + 2^1 + 2^2 + ... 2^(h-1) + 2^(h) = -h + (2^h -2) + 2^h = 2^(h+1) - h - 2
           将h=log2n, 代入S, 得到 S = 2*n - log2n -2
           也就是S: O(n)
2. 排序
    以大顶堆为例, 堆化完成后第一个元素就是最大的值, 取出第一个元素. O(n)
    将最后一个元素放到第一个位置, 进行排序, 因为其他元素都是有序的, 只需要对现在的第一个元素进行排序
        根据堆的定义, 最多需要进行堆的高度-1次比较, 取出此时的第一个元素. O(logn)
    迭代选取最后的元素, 当只剩一个元素是, 就完成了堆的排序. O(n * logn)
3. 时间复杂度
    根据堆排序的过程, 首次全部元素的堆化需要O(n), 剩余元素的排序过程需要O(nlogn).
    二者是串联的关系, 取高的时间复杂度, 也就是O(nlogn)
## Note
