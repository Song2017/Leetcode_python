
# 堆 
堆是一种特殊的树. 有意义的是堆顶元素
## 应用
堆排序, 堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法
? 堆排序比快速排序的时间复杂度稳定，但是，在实际的软件开发中，快速排序的性能要比堆排序好
## 概念
1. 堆是一个完全二叉树
    这使得堆可以用数组来存储
    除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列
2. 堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值
    去掉了子节点之间的关系限制后, 降低了实现复杂度, 提高了排序性能
    大于: 大顶堆, 小于: 小顶堆
## 实现一个堆
1. 堆的存储
    存储堆的数组, 重点区分元素的值和元素的索引, 我们计算的是元素的索引, 数组索引有下面的规律:
    根节点从第1个位置开始时, 元素的索引值是一致的:
        节点索引为i时, 左子节点:i∗2，右子节点: i∗2+1，父节点: i/2
        例: 值/索引 0 1 2 3 4 5 6 7 8, 此时1所在的索引值为1
        节点: 左子节点, 右子节点 
            1: 2, 3
            2: 4, 5
            3: 6, 7 ...
    根节点从0开始时:
        节点索引为i时, 左子节点索引:i∗2 + 1，右子节点索引: i∗2+2，父节点索引: i-1/2
        例:值: 1 2 3 4 5 6 7 8 _, 此时1所在的元素索引为0
         索引: 0 1 2 3 4 5 6 7 9, 
        节点: 左子节点, 右子节点 
            0(1): 1(2), 2(3)
            1(2): 3(4), 4(5)
            ...
    两种保存方式都是可以的, 但是值和索引保持一致时, 计算和理解都容易很多, 这里采用第一种
2. 堆的操作
    1. 往堆中插入一个元素
        1. 堆化: 堆中插入新的元素后，进行调整，让其重新满足堆的特性的过程
            分类, 从下向上, 从上向下
        2. 插入元素不会出现破坏完全二叉树要求的情况, 一般采用从下向上堆化
            堆限制了父子节点之间的关系, 堆化过程中只要按层比对就可以了
        Code
        ```
        ```
    2. 删除堆顶元素
        1. 根据第二条概念可以知道堆顶元素存储的就是堆中数据的最大值或者最小值
        2. 删除堆顶元素后, 需要子节点进行补足, 迭代到子节点后, 容易出现空洞, 即不满足完全二叉树的情况:
            解决, 直接取最后的叶节点替换到堆顶, 然后从上向下堆化
        3. Code
        ```
        ```
## 实现堆排序
1. 建堆
    1. 从前向后: 假设堆中只有一个数据, 然后将下标从 2 到 n 的数据依次插入到堆中
    2. 从后向前: 
        大顶堆的存储数组顺序是按层排序,也就是说已完成排序堆的数组后面的数据是叶子节点, 
        再按照完全二叉树的定义, 叶子节点的下标是从n/2+1开始的, 
        我们只需要从n/2开始, 堆化到下标为1的数据就可以了
    3. 建堆的时间复杂度:  
        因为堆树每层内部的节点之间没有顺序关系, 高层的节点排序要经过低层节点, 
        所以时间复杂可以简单的记做:每层的节点数*层的高度之和
        设: 树的高度为h, 节点数为n. 已知: h = log2n
            因为叶子节点不需要进行比较, 所以不需要计算 h=0
            A: S = 2^0 * h + 2^1 * (h-1) + 2^2 * (h-2) + ... 2^(h-1) * 1
            B: 2*S =         2^1 * (h) + 2^2 * (h-1) + ...   2^(h-1) * 2  + 2^(h)
            B - A = S = -h + 2^1 + 2^2 + ... 2^(h-1) + 2^(h) = -h + (2^h -2) + 2^h = 2^(h+1) - h - 2
           将h=log2n, 代入S, 得到 S = 2*n - log2n -2
           也就是S: O(n)
2. 排序
    以大顶堆为例, 堆化完成后第一个元素就是最大的值, 第一个元素已经完成了排序. O(n)
    将最后一个元素与第一个元素互换位置, 再进行1到第n-1个元素范围的排序, 
        因为其他元素都是有序的, 只需要对现在的第一个元素进行排序
        根据堆的定义, 最多需要进行 (堆的高度-1次) 比较, 交换排序范围内的首元素与最后一个元素. O(logn)
    迭代交换排序范围内首元素与最后的元素, 当只剩一个元素时, 就完成了堆的排序. O(n * logn)
    Code
    ```
    ```
3. 时间复杂度
    根据堆排序的过程, 首次全部元素的堆化需要O(n), 剩余元素的排序过程需要O(nlogn).
    二者是串联的关系, 取高的时间复杂度, 也就是O(nlogn)
4. 稳定性
    因为存在交换排序范围内首元素和最后一个元素, 所以存在交换相同数值的原始相对顺序
5. 原地排序
    我们只需要将原始的堆数组划分为待排序区域与已排序区域, 再加上个别的临时存储空间, 
    所以是原地排序

## Note
1. 为什么快速排序要比堆排序性能好
快速排序，平均情况下，它的时间复杂度为 O(nlogn)。
这两种排序算法的时间复杂度都是 O(nlogn)，甚至堆排序比快速排序的时间复杂度还要稳定，
    快速排序的基准值选取不合适时, 极端情况下会退化到O(n^2)
但是，在实际的软件开发中，快速排序的性能要比堆排序好，这是为什么呢
    1. 堆排序数据访问的方式没有快速排序友好
        快速排序的数据是顺序访问的。而对于堆排序来说，数据是跳着访问的.
        快速排序进行局部的顺序访问，对 CPU的缓存机制 是友好的.
2. CPU的缓存机制
    1. CPU每次从内存读取数据并不是只读取那个特定要访问的地址，而是读取一个数据并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要再从内存中取。
    这样就实现了比内存访问速度更快的机制，也就是CPU缓存的意义:为了弥补内存访问速度过慢与CPU执行速度快之间的差异而引入