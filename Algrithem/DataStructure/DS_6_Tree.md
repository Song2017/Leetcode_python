# 树 
树是一种非线性数据结构，它是由n（n>=1）个有限结点组成一个具有层次关系的集合.
## 概念
1. 节点: 组成树的元素
为了更好的描述节点间的关系, 对节点间的关系进行了定义.
    父节点,子节点,兄弟节点
    根节点,叶节点
2. Height, Depth, Level
节点的高度: 节点到叶节点的最长边数, 从下向上度量
节点的深度: 根节点到此节点的边数, 从上向下度量
节点的层数: 节点的深度 + 1
树的高度: 根节点的高度
## 二叉树
每个节点至多有两个子节点的树, 称之为左子节点和右子节点
二叉树是最常用的, 当然根据子节点的最大个数, 还可以分为四叉, 八叉...
### 二叉树的存储
1. 基于指针的二叉链式存储法
```
    class TreeNode:
        def __init__(self, x):
            self.val = x
            self.left = None
            self.right = None
```            
2. 基于数组的顺序存储法
节点X存储在数组中下标为i的位置,下标为2 * i的位置存储的就是左子节点,下标为 2 * i+1的位置存储的就是右子节点。
反过来，下标为 i/2 的位置存储就是它的父节点。
通过这种方式，我们只要知道根节点存储的位置（一般情况下，为了方便计算子节点，根节点会存储在下标为 1 的位置）
### 二叉树的分类
为了更好的使用二叉树解决查询,排序等操作, 根据常用的结构对二叉树进行分类
1. 满二叉树: 除叶节点外, 每个节点都有两个子节点. 每层的节点数目: 1,2,4,8..
2. 完全二叉树: 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，
    并且除了最后一层，其他层的节点个数都要达到最大
    1. 直观的, 满二叉树是一种特殊的完全二叉树
    2. 为什么最后一层的页节点要靠左排列? 
        基于数组的顺序存储时, 靠左排列可以更好的节省内存
    3. 堆: 用数组存储的完全二叉树
3. 二叉查找树(二叉搜索树): 任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，
    而右子树节点的值都大于这个节点的值
    1. 中序遍历的二叉查找树的结果是有序的
    2. 树的高度没有限制, 时间复杂度跟O(Height)成正比
### 二叉树的遍历
分类的标准是节点与它的左右子树节点遍历打印的先后顺序
前序遍历: 先打印这个节点，然后再打印它的左子树，最后打印它的右子树
    preOrder(r) = print r->preOrder(r->left)->preOrder(r->right)
    A-> B-> D-> H-> I-> E-> C-> F-> G
中序遍历: 先打印它的左子树，然后再打印它本身，最后打印它的右子树
    画图得结果, 将每层的节点垂直的落到底层上就是遍历的结果   
    H-> D-> I-> B-> E-> A-> F-> C-> G
后序遍历: 先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身
    postOrder(r) = postOrder(r->left)->postOrder(r->right)->print r
    H-> I-> D-> E-> B-> F-> G-> C-> A
层序遍历: 按层遍历, 借用队列辅助，根节点先入队列，
    然后循环从队列中pop节点，将pop出来的节点的左子节点先入队列，右节点后入队列，依次循环，直到队列为空，遍历结束

#### 遍历的实现
1. 中序遍历
    inOrder(r) = inOrder(r->left)->print r->inOrder(r->right)
    rtn, stack = [], []
    while stack or root:
        if root:
            stack.append(root)
            root = root.left
        else:
            root = stack.pop()
            rtn.append(root.val)
            root = root.right 

#### 时间复杂度
根据递推公式, 每个子节点要访问节点一次, 也就是说节点最多被访问两次, O(n)
### Note
1. 给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树
    [卡特兰数](https://en.wikipedia.org/wiki/Catalan_number) * 排列(无重复值时n!)
    Catalon number: f(n) = f(k) * f(n-k-1)，k: 0... n - 1 
                    f(n) = f(0)f(n-1) + ... + f(n-1)f(0) 